结构体变量大小是它所有成员的大小之和

```
struct stu{
	int num;
	int age;
}boy;

struct stu1{
	char sex;
	int age;
}lucy;


int main(){
	printf("%d\n",sizeof(boy));//结果为 8
	
	printf("sizeof(lucy)=%d\n",sizeof(lucy));//预期结果为5=1+4，实际结果为
	printf(&lucy=%p\n" &lucy);//第一个成员的地址
	printf("&(lucy.sex)=%p\n"， &(lucy.sex));//第一个成员的地址
	printf("&(lucy.age)=%p\n"，&(lucy.age));//与第一个成员的地址编号差4
	return 0;
}
```
给结构体变量分配内存的时候是有规则的
例子中的第一个元素的地址中间有三个字节空间没用，为了提高存取数据的速度32平台是4字节寻址的，如果挨着存可能要取两次才能取到数据，如果四字节四字节存一次就能取出，能够提高存取数据的速度

## 规则

### 规则1、以多少个字节为单位开辟内存

给结构体变量分配内存的时候，会去结构体变量中找基本类型的成员中哪个基本类型的成员占字节数多，就以它大大小为单位开辟内存

在 gcc中出现了 double 类型的例外

（1）成员中只有 char 型数据 ，以1字节为单位开辟内存。
（2）成员中出现了 short int 类型数据，没有更大字节数的基本类型数据以 2 字节为单位开辟内存
（3）出现了 imt float 没有更大字节的基本类型数据的时候以 4 字节为单位开内存
（4）出现了 double 类型的数据
	情况 1:
		在 vc6.0 和 Visual Studio 中里，以8 字节为单位开辟内存。
	情况 2:
		在 Linux 环境 gcc.里，以4 字节为单位开辟内存
无论是那种环境，double 型变量，占8 字节（linux）开辟两次四字节

如果在结构体中出现了数组，数组可以看成多个变量的集合。如果出现指针的话，没有占字节数更大的类型的，以4 字节为单位开辟内存
在内存中存储结构体成员的时候，按定义的结构体成员的顺序存储。

### 规则 2:字节对齐
(1) char 1 字节对齐 ，即存放 char 型的变量，内存单元的编号是 1的倍数即可。
(2) short int2 字节对齐 ，即存放 short int 型的变量，起始内存单元的编号是 2 的倍数即可。
(3) int4 字节对齐 ，即存放 int 型的变量，起始内存单元的编号是 4 的倍数即可
(4) long int 在 32 位平台下，4 字节对齐 ，即存放long int 型的变量，起始内存单元的编号是4的倍数即可
(5) float 4 字节对齐 ，即存放 float 型的变量，起始内存单元的编号是 4 的倍数即可(6) double
a.vc6.0 和Visual Studio 环境下
8 字节对齐，即存放 double 型变量的起始地址，必须是 8 的倍数，double 变量占8 字节
b.gcc 环境下

4 字节对齐，即存放 double 型变量的起始地址，必须是 4 的倍数，double 变量占8 字节。

当结构体成员中出现数组的时候，可以看成多个变量
开辟内存的时候，从上向下依次按成员在结构体中的位置顺序开辟空间

#### 为什么要有字节对齐
用空间来换时间，提高 cpu 读取数据的效率

## 指定对齐原则:
使用#pragma pack改变默认对齐原则格式:

```
#pragma pack (value)时的指定对齐值value。
```
value只能是 1 2 4 8等
结构体成员中，占字节数最大的类型长度和value比较取较小值，为单位开辟内存