### 定义方法:

```
指向的数组的类型 (*指针变量名)[指向的数组的元素个数]
int(*p)[5];//定义了一个数组指针变量 p，p指向的是整型的有 5 个元素的数组p+1 往下指 5 个整型，跳过一个有 5 个整型元素的数组
```

```
#include<stdio.h>
int main(){
int a[3][5];//定义了一个 3 行 5 列的一个二维数组
int(*p)[5];//定义一个数组指针变量 p，p+1跳一个有 5 个元素的整型数组printf("a=%p\n",a);//第 0 行的行地址
printf("a+1=%p\n"a+1);//第 1行的行地址，a和a +1差 20 个字节
p=a;
printf("p=%p\n",p);
printf("p+1=%p\n",p+1);//p+1跳一个有 5 个整型元素的一维数组
return 0;
}
```

## 各种数组指针的定义:
1、一维数组指针，加 1后指向下个一维数组

```
int(*p)[5]; // int *p[5];
```
配合每行有 5个 int 型元素的二维数组来用

2、二维数组指针，加 1后指向下个二维数组

```
int(*p)[4][5];
```
配合三维数组来用，三维数组中由若干个 4 行 5 列二维数组构成
```
int a[3][4][5];
```

3、三维数组指针，加 1后指向下个三维数组
```
int(*p)[4][5][6];// p+1 跳一个三维数组:
```

由4个5行6列的二维数组构成的三维数组配合使用
```
int a[7][4][5][6];
```

四维数组指针，加1后指向下个四维数组，以此类推。。。。

# 注意

### 指针数组
是个数组，有若干个相同类型的指针构成的集合

int * p[10];
数组 p有 10 个 int * 类型的指针变量构成，分别是 p[0] ~p[9]

### 数组指针
本身是个指针，指向一个数组加1跳一个数组
int (* p)[10];
P 是个指针，p 是个数组指针，p 加 1指向下个数组，跳 10 个整形。

### 指针的指针:
```
int **p;//p 是指针的指针
int *q
p=&q;
```

a 是个 int* 类型的指针，是 a[0]的地址。
&a 变成了数组指针，加 1跳一个 10 个元素的整型一维数组

在运行程序时，a和&a 所代表的地址编号是一样的，即他们指向同一个存储单元，但是 a和&a 的指针类型不同。
```
int a[4][5];

```
a+1跳5个整型
(&a)+1跳4行5列( 80 个字节)

c 语言规定，数组名字取地址，变成了数组指针。加 1跳一个数组

### 数组名字和指针变量的区别
```
int a[5];
int *p;
p=a;
```

#### 相同点:

a 是数组的名字，是 a[0]的地址，p=a 即p 保存了 a [0]的地址，即a 和p 都指向 a[0]，所以在引用数组元素的时候，a和p等价

引用数组元素回顾:
a[2]、*(a+2)、p[2]、*(p+2) 都是对数组a 中 a[2]元素的引用。

#### 不同点:
1、a 是常量、p 是变量可以用等号’=给p 赋值，但是不能用等号给 a 赋值

2、对 a 取地址，和对 p 取地址结果不同因为 a 是数组的名字，所以对 a 取地址结果为数组指针。
p 是个指针变量，所以对 p 取地址 (&p) 结果为指针的指针

```
int a[5]={0,1,2,3,4};
int *p=a;
```
假如 a[0]的地址为 0x00002000.p 的地址为 0x00003000
1、&p 是指针的指针，为 int ** 类型，结果为 0x00003000，&p +1，往后指向一个 int* 类型的指针，地址编号差 4
2、&a 结果是数组指针，为 int(* )[5]类型，结果还是 0x00002000，&a +1,往后指一个数组(有5个整型元素的一维数组)，地址编号差 20